use crate::{amalgamator, discovery, types::Result};
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

pub struct Builder {
    patterns: Vec<String>,
    output_dir: Option<PathBuf>,
    validate: bool,
}

impl Builder {
    pub fn new() -> Self {
        Self {
            patterns: Vec::new(),
            output_dir: None,
            validate: true,
        }
    }
    
    pub fn add_pattern<S: AsRef<str>>(mut self, pattern: S) -> Self {
        self.patterns.push(pattern.as_ref().to_string());
        self
    }
    
    pub fn output_dir<P: AsRef<Path>>(mut self, dir: P) -> Self {
        self.output_dir = Some(dir.as_ref().to_path_buf());
        self
    }
    
    pub fn validate_templates(mut self, validate: bool) -> Self {
        self.validate = validate;
        self
    }
    
    pub fn build(self) -> Result<()> {
        let out_dir = self.output_dir
            .or_else(|| env::var_os("OUT_DIR").map(PathBuf::from))
            .expect("OUT_DIR not set and no output_dir specified");
        
        // Tell Cargo to rerun if any tomplate files change
        for pattern in &self.patterns {
            println!("cargo:rerun-if-changed={}", pattern);
        }
        
        // Discover all template files
        let template_files = discovery::discover_templates(&self.patterns)?;
        
        if template_files.is_empty() {
            // No templates found, create empty constants
            Self::write_empty_templates(&out_dir)?;
            return Ok(());
        }
        
        // Amalgamate all templates into a single TOML structure
        let amalgamated = amalgamator::amalgamate_templates(&template_files)?;
        
        // Write the amalgamated TOML file
        let toml_path = out_dir.join("tomplate_amalgamated.toml");
        fs::write(&toml_path, &amalgamated)?;
        
        // Generate the Rust code that includes the TOML as a static string
        let rust_code = format!(
            r#"// Auto-generated by tomplate-build
pub const TOMPLATE_TEMPLATES: &str = include_str!("tomplate_amalgamated.toml");
"#
        );
        
        let rust_path = out_dir.join("tomplate_templates.rs");
        fs::write(&rust_path, rust_code)?;
        
        println!("cargo:rustc-env=TOMPLATE_TEMPLATES_PATH={}", rust_path.display());
        
        Ok(())
    }
    
    fn write_empty_templates(out_dir: &Path) -> Result<()> {
        // Write empty TOML file
        let toml_path = out_dir.join("tomplate_amalgamated.toml");
        fs::write(&toml_path, "")?;
        
        // Generate Rust code with empty templates
        let rust_code = r#"// Auto-generated by tomplate-build
pub const TOMPLATE_TEMPLATES: &str = "";
"#;
        
        let rust_path = out_dir.join("tomplate_templates.rs");
        fs::write(&rust_path, rust_code)?;
        
        Ok(())
    }
}

impl Default for Builder {
    fn default() -> Self {
        Self::new()
    }
}